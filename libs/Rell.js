(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Rell"] = factory();
	else
		root["Rell"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./Rell.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./Rell.js":
/*!*****************!*\
  !*** ./Rell.js ***!
  \*****************/
/*! exports provided: render, Component */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return Component; });\n/* harmony import */ var xml_reader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xml-reader */ \"./node_modules/xml-reader/dist/reader.js\");\n/* harmony import */ var xml_reader__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(xml_reader__WEBPACK_IMPORTED_MODULE_0__);\n\nlet mainMountPoint = null;\nlet registeredComponents = {};\n\nconst outPutHt2ml = node => {\n  let element = null;\n\n  if (node instanceof Array) {\n    return node.map(outPutHtml);\n  }\n\n  const mountPoint = node.parentToAppend || mainMountPoint;\n\n  if (node.type == 'element') {\n    if (node.name[0] == node.name[0].toUpperCase()) {\n      const customElement = registeredComponents[node.name];\n      stringToDOM(customElement.render(), renderNodes => {\n        renderNodes.parentToAppend = mountPoint;\n        outPutHtml(renderNodes);\n      });\n    } else {\n      element = document.createElement(node.name);\n      mountPoint.append(element);\n    }\n  }\n\n  if (node.type == 'text') {\n    console.log(node.value);\n    mountPoint.innerHTML = node.value;\n  }\n\n  if (node.children) {\n    node.children.forEach(node => node.parentToAppend = element);\n    return outPutHtml(node.children);\n  }\n};\n\nconst stringToDOM = (content, cb) => {\n  const reader = xml_reader__WEBPACK_IMPORTED_MODULE_0___default.a.create();\n  reader.on('done', cb);\n  reader.parse(content);\n};\n\nconst render = (content, mountPoint) => {\n  mainMountPoint = mountPoint;\n  stringToDOM(content, outPutHtml);\n};\n\nconst Component = componentClass => {\n  const component = new componentClass();\n  registeredComponents[component.constructor.name] = component;\n};\n\n\n\n//# sourceURL=webpack://Rell/./Rell.js?");

/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @api private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {Mixed} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @api public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Boolean} exists Only check if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event, exists) {\n  var evt = prefix ? prefix + event : event\n    , available = this._events[evt];\n\n  if (exists) return !!available;\n  if (!available) return [];\n  if (available.fn) return [available.fn];\n\n  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n    ee[i] = available[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Function} fn The listener function.\n * @param {Mixed} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;\n  else if (!this._events[evt].fn) this._events[evt].push(listener);\n  else this._events[evt] = [this._events[evt], listener];\n\n  return this;\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Function} fn The listener function.\n * @param {Mixed} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;\n  else if (!this._events[evt].fn) this._events[evt].push(listener);\n  else this._events[evt] = [this._events[evt], listener];\n\n  return this;\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {Mixed} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    if (--this._eventsCount === 0) this._events = new Events();\n    else delete this._events[evt];\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n         listeners.fn === fn\n      && (!once || listeners.once)\n      && (!context || listeners.context === context)\n    ) {\n      if (--this._eventsCount === 0) this._events = new Events();\n      else delete this._events[evt];\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n           listeners[i].fn !== fn\n        || (once && !listeners[i].once)\n        || (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else if (--this._eventsCount === 0) this._events = new Events();\n    else delete this._events[evt];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {String|Symbol} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) {\n      if (--this._eventsCount === 0) this._events = new Events();\n      else delete this._events[evt];\n    }\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n\n\n//# sourceURL=webpack://Rell/./node_modules/eventemitter3/index.js?");

/***/ }),

/***/ "./node_modules/xml-lexer/dist/lexer.js":
/*!**********************************************!*\
  !*** ./node_modules/xml-lexer/dist/lexer.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\nvar noop = function noop() {};\n\nvar State = {\n    data: 'state-data',\n    cdata: 'state-cdata',\n    tagBegin: 'state-tag-begin',\n    tagName: 'state-tag-name',\n    tagEnd: 'state-tag-end',\n    attributeNameStart: 'state-attribute-name-start',\n    attributeName: 'state-attribute-name',\n    attributeNameEnd: 'state-attribute-name-end',\n    attributeValueBegin: 'state-attribute-value-begin',\n    attributeValue: 'state-attribute-value'\n};\n\nvar Action = {\n    lt: 'action-lt',\n    gt: 'action-gt',\n    space: 'action-space',\n    equal: 'action-equal',\n    quote: 'action-quote',\n    slash: 'action-slash',\n    char: 'action-char',\n    error: 'action-error'\n};\n\nvar Type = {\n    text: 'text',\n    openTag: 'open-tag',\n    closeTag: 'close-tag',\n    attributeName: 'attribute-name',\n    attributeValue: 'attribute-value'\n};\n\nvar charToAction = {\n    ' ': Action.space,\n    '\\t': Action.space,\n    '\\n': Action.space,\n    '\\r': Action.space,\n    '<': Action.lt,\n    '>': Action.gt,\n    '\"': Action.quote,\n    \"'\": Action.quote,\n    '=': Action.equal,\n    '/': Action.slash\n};\n\nvar getAction = function getAction(char) {\n    return charToAction[char] || Action.char;\n};\n\n/**\n * @param  {Object} options\n * @param  {Boolean} options.debug\n * @return {Object}\n */\nvar create = function create(options) {\n    var _State$data, _State$tagBegin, _State$tagName, _State$tagEnd, _State$attributeNameS, _State$attributeName, _State$attributeNameE, _State$attributeValue, _State$attributeValue2, _lexer$stateMachine;\n\n    options = Object.assign({ debug: false }, options);\n    var lexer = new EventEmitter();\n    var state = State.data;\n    var data = '';\n    var tagName = '';\n    var attrName = '';\n    var attrValue = '';\n    var isClosing = '';\n    var openingQuote = '';\n\n    var emit = function emit(type, value) {\n        // for now, ignore tags like: '?xml', '!DOCTYPE' or comments\n        if (tagName[0] === '?' || tagName[0] === '!') {\n            return;\n        }\n        var event = { type: type, value: value };\n        if (options.debug) {\n            console.log('emit:', event);\n        }\n        lexer.emit('data', event);\n    };\n\n    lexer.stateMachine = (_lexer$stateMachine = {}, _defineProperty(_lexer$stateMachine, State.data, (_State$data = {}, _defineProperty(_State$data, Action.lt, function () {\n        if (data.trim()) {\n            emit(Type.text, data);\n        }\n        tagName = '';\n        isClosing = false;\n        state = State.tagBegin;\n    }), _defineProperty(_State$data, Action.char, function (char) {\n        data += char;\n    }), _State$data)), _defineProperty(_lexer$stateMachine, State.cdata, _defineProperty({}, Action.char, function (char) {\n        data += char;\n        if (data.substr(-3) === ']]>') {\n            emit(Type.text, data.slice(0, -3));\n            data = '';\n            state = State.data;\n        }\n    })), _defineProperty(_lexer$stateMachine, State.tagBegin, (_State$tagBegin = {}, _defineProperty(_State$tagBegin, Action.space, noop), _defineProperty(_State$tagBegin, Action.char, function (char) {\n        tagName = char;\n        state = State.tagName;\n    }), _defineProperty(_State$tagBegin, Action.slash, function () {\n        tagName = '';\n        isClosing = true;\n    }), _State$tagBegin)), _defineProperty(_lexer$stateMachine, State.tagName, (_State$tagName = {}, _defineProperty(_State$tagName, Action.space, function () {\n        if (isClosing) {\n            state = State.tagEnd;\n        } else {\n            state = State.attributeNameStart;\n            emit(Type.openTag, tagName);\n        }\n    }), _defineProperty(_State$tagName, Action.gt, function () {\n        if (isClosing) {\n            emit(Type.closeTag, tagName);\n        } else {\n            emit(Type.openTag, tagName);\n        }\n        data = '';\n        state = State.data;\n    }), _defineProperty(_State$tagName, Action.slash, function () {\n        state = State.tagEnd;\n        emit(Type.openTag, tagName);\n    }), _defineProperty(_State$tagName, Action.char, function (char) {\n        tagName += char;\n        if (tagName === '![CDATA[') {\n            state = State.cdata;\n            data = '';\n            tagName = '';\n        }\n    }), _State$tagName)), _defineProperty(_lexer$stateMachine, State.tagEnd, (_State$tagEnd = {}, _defineProperty(_State$tagEnd, Action.gt, function () {\n        emit(Type.closeTag, tagName);\n        data = '';\n        state = State.data;\n    }), _defineProperty(_State$tagEnd, Action.char, noop), _State$tagEnd)), _defineProperty(_lexer$stateMachine, State.attributeNameStart, (_State$attributeNameS = {}, _defineProperty(_State$attributeNameS, Action.char, function (char) {\n        attrName = char;\n        state = State.attributeName;\n    }), _defineProperty(_State$attributeNameS, Action.gt, function () {\n        data = '';\n        state = State.data;\n    }), _defineProperty(_State$attributeNameS, Action.space, noop), _defineProperty(_State$attributeNameS, Action.slash, function () {\n        isClosing = true;\n        state = State.tagEnd;\n    }), _State$attributeNameS)), _defineProperty(_lexer$stateMachine, State.attributeName, (_State$attributeName = {}, _defineProperty(_State$attributeName, Action.space, function () {\n        state = State.attributeNameEnd;\n    }), _defineProperty(_State$attributeName, Action.equal, function () {\n        emit(Type.attributeName, attrName);\n        state = State.attributeValueBegin;\n    }), _defineProperty(_State$attributeName, Action.gt, function () {\n        attrValue = '';\n        emit(Type.attributeName, attrName);\n        emit(Type.attributeValue, attrValue);\n        data = '';\n        state = State.data;\n    }), _defineProperty(_State$attributeName, Action.slash, function () {\n        isClosing = true;\n        attrValue = '';\n        emit(Type.attributeName, attrName);\n        emit(Type.attributeValue, attrValue);\n        state = State.tagEnd;\n    }), _defineProperty(_State$attributeName, Action.char, function (char) {\n        attrName += char;\n    }), _State$attributeName)), _defineProperty(_lexer$stateMachine, State.attributeNameEnd, (_State$attributeNameE = {}, _defineProperty(_State$attributeNameE, Action.space, noop), _defineProperty(_State$attributeNameE, Action.equal, function () {\n        emit(Type.attributeName, attrName);\n        state = State.attributeValueBegin;\n    }), _defineProperty(_State$attributeNameE, Action.gt, function () {\n        attrValue = '';\n        emit(Type.attributeName, attrName);\n        emit(Type.attributeValue, attrValue);\n        data = '';\n        state = State.data;\n    }), _defineProperty(_State$attributeNameE, Action.char, function (char) {\n        attrValue = '';\n        emit(Type.attributeName, attrName);\n        emit(Type.attributeValue, attrValue);\n        attrName = char;\n        state = State.attributeName;\n    }), _State$attributeNameE)), _defineProperty(_lexer$stateMachine, State.attributeValueBegin, (_State$attributeValue = {}, _defineProperty(_State$attributeValue, Action.space, noop), _defineProperty(_State$attributeValue, Action.quote, function (char) {\n        openingQuote = char;\n        attrValue = '';\n        state = State.attributeValue;\n    }), _defineProperty(_State$attributeValue, Action.gt, function () {\n        attrValue = '';\n        emit(Type.attributeValue, attrValue);\n        data = '';\n        state = State.data;\n    }), _defineProperty(_State$attributeValue, Action.char, function (char) {\n        openingQuote = '';\n        attrValue = char;\n        state = State.attributeValue;\n    }), _State$attributeValue)), _defineProperty(_lexer$stateMachine, State.attributeValue, (_State$attributeValue2 = {}, _defineProperty(_State$attributeValue2, Action.space, function (char) {\n        if (openingQuote) {\n            attrValue += char;\n        } else {\n            emit(Type.attributeValue, attrValue);\n            state = State.attributeNameStart;\n        }\n    }), _defineProperty(_State$attributeValue2, Action.quote, function (char) {\n        if (openingQuote === char) {\n            emit(Type.attributeValue, attrValue);\n            state = State.attributeNameStart;\n        } else {\n            attrValue += char;\n        }\n    }), _defineProperty(_State$attributeValue2, Action.gt, function (char) {\n        if (openingQuote) {\n            attrValue += char;\n        } else {\n            emit(Type.attributeValue, attrValue);\n            data = '';\n            state = State.data;\n        }\n    }), _defineProperty(_State$attributeValue2, Action.slash, function (char) {\n        if (openingQuote) {\n            attrValue += char;\n        } else {\n            emit(Type.attributeValue, attrValue);\n            isClosing = true;\n            state = State.tagEnd;\n        }\n    }), _defineProperty(_State$attributeValue2, Action.char, function (char) {\n        attrValue += char;\n    }), _State$attributeValue2)), _lexer$stateMachine);\n\n    var step = function step(char) {\n        if (options.debug) {\n            console.log(state, char);\n        }\n        var actions = lexer.stateMachine[state];\n        var action = actions[getAction(char)] || actions[Action.error] || actions[Action.char];\n        action(char);\n    };\n\n    lexer.write = function (str) {\n        var len = str.length;\n        for (var i = 0; i < len; i++) {\n            step(str[i]);\n        }\n    };\n\n    return lexer;\n};\n\nmodule.exports = {\n    State: State,\n    Action: Action,\n    Type: Type,\n    create: create\n};\n\n//# sourceURL=webpack://Rell/./node_modules/xml-lexer/dist/lexer.js?");

/***/ }),

/***/ "./node_modules/xml-reader/dist/reader.js":
/*!************************************************!*\
  !*** ./node_modules/xml-reader/dist/reader.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\nvar Lexer = __webpack_require__(/*! xml-lexer */ \"./node_modules/xml-lexer/dist/lexer.js\");\nvar Type = Lexer.Type;\n\nvar NodeType = {\n    element: 'element',\n    text: 'text'\n};\n\nvar createNode = function createNode(params) {\n    return Object.assign({\n        name: '',\n        type: NodeType.element,\n        value: '',\n        parent: null,\n        attributes: {},\n        children: []\n    }, params);\n};\n\nvar create = function create(options) {\n    options = Object.assign({\n        stream: false,\n        parentNodes: true,\n        doneEvent: 'done',\n        tagPrefix: 'tag:',\n        emitTopLevelOnly: false,\n        debug: false\n    }, options);\n\n    var lexer = void 0,\n        rootNode = void 0,\n        current = void 0,\n        attrName = void 0;\n\n    var reader = new EventEmitter();\n\n    var handleLexerData = function handleLexerData(data) {\n        switch (data.type) {\n\n            case Type.openTag:\n                if (current === null) {\n                    current = rootNode;\n                    current.name = data.value;\n                } else {\n                    var node = createNode({\n                        name: data.value,\n                        parent: current\n                    });\n                    current.children.push(node);\n                    current = node;\n                }\n                break;\n\n            case Type.closeTag:\n                var parent = current.parent;\n                if (!options.parentNodes) {\n                    current.parent = null;\n                }\n                if (current.name !== data.value) {\n                    // ignore unexpected closing tag\n                    break;\n                }\n                if (options.stream && parent === rootNode) {\n                    rootNode.children = [];\n                    // do not expose parent node in top level nodes\n                    current.parent = null;\n                }\n                if (!options.emitTopLevelOnly || parent === rootNode) {\n                    reader.emit(options.tagPrefix + current.name, current);\n                    reader.emit('tag', current.name, current);\n                }\n                if (current === rootNode) {\n                    // end of document, stop listening\n                    lexer.removeAllListeners('data');\n                    reader.emit(options.doneEvent, current);\n                    rootNode = null;\n                }\n                current = parent;\n                break;\n\n            case Type.text:\n                if (current) {\n                    current.children.push(createNode({\n                        type: NodeType.text,\n                        value: data.value,\n                        parent: options.parentNodes ? current : null\n                    }));\n                }\n                break;\n\n            case Type.attributeName:\n                attrName = data.value;\n                current.attributes[attrName] = '';\n                break;\n\n            case Type.attributeValue:\n                current.attributes[attrName] = data.value;\n                break;\n        }\n    };\n\n    reader.reset = function () {\n        lexer = Lexer.create({ debug: options.debug });\n        lexer.on('data', handleLexerData);\n        rootNode = createNode();\n        current = null;\n        attrName = '';\n        reader.parse = lexer.write;\n    };\n\n    reader.reset();\n    return reader;\n};\n\nvar parseSync = function parseSync(xml, options) {\n    options = Object.assign({}, options, { stream: false, tagPrefix: ':' });\n    var reader = create(options);\n    var res = void 0;\n    reader.on('done', function (ast) {\n        res = ast;\n    });\n    reader.parse(xml);\n    return res;\n};\n\nmodule.exports = {\n    parseSync: parseSync,\n    create: create,\n    NodeType: NodeType\n};\n\n//# sourceURL=webpack://Rell/./node_modules/xml-reader/dist/reader.js?");

/***/ })

/******/ });
});